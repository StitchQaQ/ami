---
title: "Redis 核心知识"
date: 2025-02-05T09:39:00+08:00
draft: false
description: "Redis 数据类型、持久化、集群等核心概念"
tags: ["Redis", "数据库"]
categories: ["后端开发"]
author: "Heyuuuu"
lastmod: 2025-11-24T18:00:00+08:00
---


#### 数据类型
- String: 字符串
- Hash: 哈希, 是一个键值对集合，类似于 Python 中的字典。适合存储对象，一个哈希可以包含多个字段和对应的值，每个哈希最多可存储2^32 -1个键值对。
    - 常见命令:
        1. 设置单个字段值：HSET key field value，例如 HSET user:1 name "Bob"。
        2. 获取单个字段值：HGET key field，例如 HGET user:1 name 会返回 "Bob"。
        3. 获取所有字段和值：HGETALL key。

- List: 列表
    - 常见命令:
        LPUSH RPUSH LPOP RPOP LINDEX LRANGE LTRIM 等
        是一个有序，可以重复的线性数据结构，基于双向链表，支持快速的插入和删除操作。
        1. LPUSH key value [value ...]：将一个或多个值插入到列表的头部。
        2. RPUSH key value [value ...]：将一个或多个值插入到列表的尾部。
        3. LPOP key：移除并返回列表的第一个元素。
        4. RPOP key：移除并返回列表的最后一个元素。
        5. LINDEX key index：返回列表中指定索引的元素。
        6. LRANGE key start stop：返回列表中指定范围内的元素。
        7. LTRIM key start stop：截取列表，只保留指定范围内的元素。

    - 消息队列: FIFO (First In First Out)
        1. LPUSH + RPOP 
        2. LPUSH + BRPOP(阻塞式右取出)

    - 栈: LIFO (Last In First Out)
        1. LPUSH + LPOP
        2. RPUSH + RPOP
        
        
- Set: 集合
    - 常见命令:
        SADD SMEMBERS SREM SISMEMBER SCARD 等
        是一个无序，不重复的集合数结构，基于哈希表实现，支持快速的插入、删除和查找操作。
        1. SADD key member [member...]：向集合中添加一个或多个成员。
    - 常用场景:
        点赞/投票， 关注/取消关注， 共同关注， 推荐系统。
        1. 去重：集合可以用于存储唯一的元素，例如用户 ID 列表。
        2. 交集、并集、差集：可以对多个集合进行交集、并集、差集操作，例如找出两个用户共同关注的话题。
        3. ZRANGE key start stop：返回有序集合中指定范围内的元素。
        4. ZREM key member：移除有序集合中的一个或多个成员。
        5. ZSCORE key member：返回有序集合中指定成员的分数。
        6. ZINCRBY key increment member：增加有序集合中指定成员的分数。
        7. SISMEMBER key member：判断成员是否在集合中. 

- Sorted Set: 有序集合
    - 核心用途
        - 排行榜
        ```
            ZADD leaderboard 1000 "player1"  # 玩家1得分1000
            ZADD leaderboard 800 "player2"  # 玩家2得分800
            ZREVRANGE leaderboard 0 2  # 获取排行榜前3名（降序）
        ```
        - 消息队列
        - 延时任务
        - 计数器




### Redis的几种集群方式
##### 主从复制（Master-Slave) -- 基础高可用
1个主节点 + N个从节点。
从节点通过 replicaof 命令（旧版是 slaveof） 跟随主及诶单。主节点将携操作同步到所有从节点（异步复制，主节点写入成功后理解返回客户端，无需等待从节点同步完成）
主节点负责【写操作】, SET DEL等， 从节点负责读操作 GET LRANGE。 客户端需要手动区分读写请求的目标节点
主节点故障后，需要手动将一个从节点升级为新的主节点（无自动故障转移）， 原主节点回复后需要手动调整为从节点
核心特点：
    - 优点：简单，支持读写分离，提供读并发，数据备份
    - 缺点：没有自动故障转移，不支持数据分片（所有节点存储全量数据，无法突破单节点内存上限），写操作仍集中在主节点。

##### 哨兵模式（Sentinel）-- 自动高可用方案
主从复制集群 + 3个以上哨兵节点（Sentinel）
哨兵的核心作用：
- 监控： 实时检测主从节点的健康状态
- 自动故障转移： 当主节点故障时，哨兵集群通过投票机制（超过半数哨兵同意）自动将一个从节点升级为新的主节点，同时更新其他从节点的主节点指向，客户端通过哨兵获取新的主节点地址（无需手动调整）

数据同步： 沿用主从复制的异步同步机制。
客户端接入： 客户端连接哨兵集群（而非直接连接主从节点）， 哨兵返回当前可用的主节点地址。客户端基于改地址发起写请求，读请求仍需手动路由到从节点。
核心特点：
    - 优点： 自动故障转移（无需手动介入，故障转移时间几秒内）
    - 缺点： 不支持分片（所有节点存储全量数据，内存上限仍受单点节点限制）， 写操作集中在主节点（并发写能力有限），哨兵集群需要单独部署（增加运维成本）


##### 分片集群（Redis Cluster） -- 海量数据高并发方案
3个及以上主节点（每个主节点对应 1-N 个从节点）， 所有节点共同组成集群
核心机制：
数据分片： 通过16384个哈希槽（Hash Slot）分配数据，每个主节点负责一部分哈希槽（如3主节点分别负责 0～5461、 5462～10922、 10923～16384）， 数据按Key的哈希值映射到对应槽，仅存储在负责该槽的主节点上（突破单节点内存上限）
路由转发： 客户端连接任意节点，节点计算Key对应的槽，若自身不负责则返回重定向响应，客户端缓存槽与节点的映射关系（后续直接访问该节点）
自动故障转移，主节点故障时，其从节点自动升级成新的主节点。接管哈希槽（高可用保障）
水平扩展，新增节点时，通过哈希槽迁移将部分数据迁移至新节点。
核心特点：
    - 优点，支持数据分片，支持水平扩展，自动故障转移，并发能力线性提升。
    - 缺点： 实现复杂度高于前两种（需要配置集群拓扑，哈希槽分配）、不支持跨槽多键操作（如 MSET 多键不在同一槽会报错，需通过哈希标签规避），运维成本较高（监控集群状态，哈希槽迁移）

| 对比维度 | 主从复制（Master-Slave） | 哨兵模式（Sentinel） | 分片集群（Redis Cluster） |
|---------|------------------------|---------------------|-------------------------|
| 核心目标 | 数据备份 + 读写分离 | 自动高可用 + 读写分离 | 海量数据 + 高并发 + 高可用 |
| 数据存储方式 | 所有节点存储全量数据 | 所有节点存储全量数据 | 数据分片存储（每个节点存部分数据） |
| 高可用（故障转移） | 手动故障转移 | 自动故障转移 | 自动故障转移 |
| 并发能力 | 读并发提升，写并发受限 | 读并发提升，写并发受限 | 读写并发线性提升（多主多从） |
| 水平扩展（扩容） | 不支持（无法突破内存上限） | 不支持（无法突破内存上限） | 支持（新增节点迁移哈希槽） |
| 复杂度（部署 + 运维） | 低 | 中 | 高 |
| 跨键操作支持 | 支持（全量数据） | 支持（全量数据） | 仅支持同槽多键操作 |
| 适用数据量 | 中小数据量（单节点可容纳） | 中小数据量（单节点可容纳） | 海量数据（单节点无法容纳） |